//<T> 제네릭 타입이 치트키처럼 종합적으로 모든 타입을 흡수하는 것은 맞지만 지나치게 의존하여 붙이면 곤란, 들어올 수 있는 친구와 들어올 수 없는 친구에 대한 타입제약이 필요하다.

//맞는 말 같지만 말장난에 지나지 않는 제네릭타입의 남발
// const create = <T>(type: T): T => new Type();

//제네릭타입변수의 남발로 인한 '타입의 타입'과 같은 부작용을 사전에 방지하기 위한 타입제약!
//
// const create = <T extends { new (): T }>(type: T): T => new type();

//new라는 예약어를 사용해서 클래스 생성자를 통한 프로토타입의 객체와 인스턴스타입의 객체를 생성하고자 할 때, 만약 인자값을 전달해야하는 상황이 발생한다면?

export const Create = <T>(type: { new (...args: T[]): T }, ...args: T[]): T =>
  new type(...args);